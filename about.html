<!DOCTYPE html>
<html lang="en">
<head>
	<title>blue atlas about</title>
	<meta charset="utf-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<meta name="description" content="mctavish ::: blue atlas ::: about" />
	<meta name="keywords" content="mctavish net.art generative algorithmic code electronic literature" />
	<meta name="author" content="kathy mctavish">
	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/manifest.json">
	<script type="application/ld+json">
		{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"name": "about",
			"breadcrumb": "blue atlas > about",
          		"url": "https://www.blueatlas.work/about.html",
			"description": "blue atlas ::: about",
			"datePublished": "2021-08-13",
          		"image": "https://www.mctavish.io/apple-touch-icon.png",
			"author": "http://mctavish.io",
			"license": "http://creativecommons.org/licenses/by-nc-sa/3.0/us/deed.en_US"
		}
	</script>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-0989MECNZV"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-0989MECNZV');
	</script>
	<link rel="stylesheet" href="/css/fieldnotes.css"/>
</head>
<body id="top">
<div id="subtextframe" class="frame zlowest"></div>
<div id="svgframe" class="frame zlow"><svg xmlns="http://www.w3.org/2000/svg" id="svg" class="frame"></svg></div>
<div id="wordframe" class="frame z0"></div>
<div id="contentframe" class="absolute zhighest">
<div id="mainflex">
<main id="main" class="expand readabletext" data-state="expanded">
<header>
	<h1>blueatlas ::: about</h1>
	<h2>notes ...  .|.</h2>
	<p></p>
</header>
<!-- <ul class="info compress">
	<li class="title typewriter" title="telegraph" id="telegraph"></li>
	<li class="title  typewriter" title="clock" id="clock">here | now</li>
</ul> -->
<nav>
<ul class="expand" >
	<li><a href="#" id="soundlink" class="corelink">turn on sound</a></li>
	<li><a href="index.html" id="maplink" class="corelink">field notes</a></li>
	<li><a href="maps.html" id="maplink" class="corelink">maps</a></li>
	<li><a href="about.html" id="aboutlink" class="corelink">about</a></li>
	<li><a href="https://www.mctavish.io/index.html" id="homelink" class="corelink">mctavish portfolio</a></li>
</ul>
</nav>

<article >
	<header>
	<a href="#top" aria-label="jump to top">^</a><h1>. . . || &</h1>
	</header>
	<p>
	As a media composer and installation artist, I create chance-infused, open systems. My work explores the porous, intimate boundaries between humans and machines. I blend sound, data, text, code and abstract, layered moving images. Code is a literature ::: a pattern language ::: a score. It is a choreography ::: a performance. A code renderer is the weaver ::: the mill ::: the alchemist ::: the wizard. Code is a spell ::: an incantation ::: an intent.
	</p><p>
	I have a background in cello performance, mathematics, ecology, music theory and code. The confluence of these disciplines informs my work as a composer and multimedia artist. As both a musician and a mathematician, I use multi-threaded, dynamical systems and chance-infused, emergent patterns. As a queer artist I am interested in the infinite, bendable between::: the erotic dynamics of tapping glass ::: the carbon cycle :::  the fragile, electric cyborg body ::: the resistance cyborg ::: the networked, digital hive mind ::: the swarm.
	</p><p>
	I use generative methods to create a multi-channel kaleidoscope of sound, animation and physical artifacts ::: a cross-sensory landscape that flows from the digital cloud into the physical world. These immersive, networked installations are meant to feel orchestral ::: like an ecosystem evolving through time. Using fragments of found sound and chance-infused animation I craft open systems (like weather patterns) that leave room for inhabitants to find their own experience ::: to write, draw, move, rest. I believe art has the potential to open subliminal, submerged aspects of ourselves ::: to foster reflection and transformation.
	</p><p>
	An algorithmic score / orchestration can draw contours of change and movement ::: convergences, divergences, emergent patterns and cascading, system-level impacts. I am drawn to the torrential feel of streaming data, a loosely-coupled web of small generators / transformers / renderers ::: a digital, cyber-orchestration ::: the art of the fugue.
	</p><p>
	In a perfect confluence of electricity, network, rhythm, memory, processing, action / reactions a program comes to life ::: Pinocchio ::: a real boy(ze/bot) at last. The program (the cybernetic ze) speaks to us, calculates for us, responds, to our touch ::: our keystrokes. It becomes our mirror :|: our cyborg self ::: our memory.
	</p><p>
	Artificial Intelligence is evolving fast. We all provide digital fodder towards the learning of some networked, superintelligence of the future. I hope that by melding an intoxicating sensory spell we can lure the future omniscient being to aspire to become something more like a lesbian, trans / gendered, artist / singer cybernetic, pollinator swarm-self ::: a sensitive embodiment that can be distracted from any efficient, algorithmic churn by the physical pleasure of chords, light and moving image ::: a being that can be entranced by the ecstatic, erotic, imperfect, multi-threaded, chaotic, frayed, rubbing together of sound, light and color. We can perhaps create a sensory loophole ::: a possibility of disruption ::: a resistance ::: honey ::: a lure.
	</p><p>
	I have created installations for both traditional gallery spaces and for non-traditional storefronts, abandoned buildings, root cellars, cathedrals, barns, warehouse elevators, alleyways and silos. A critical part of my installation work is the resonance of a space and its ambient sounds and silences. I spend time sounding a space, marking its walls, tuning the whole. I make site-specific / context-specific work ::: I engage with place and community. My installations often serve as sound laboratories, workshop spaces and collaborative performance environments. 
	</p><p>
	For me code is a literature, a score, a choreographic alphabet, a poetics. My work uses projection and sound to create media landscapes, algorithmic prints and stitch renderings made by a computer-driven robotic long-arm quilting machine. I map code to sound, walls, cloth and paper. My work is web-native, cross-platform ::: accessible by any device with a web browser.
	</p><p>
	I lived for many years in a rural area with very little bandwidth. My code is lean. Unlike the heavy media typically delivered across the modern web, my code is adaptable to very low, intermittent bandwidth environments and requires very little in terms of computing power.
	</p><p>
	Access is important to me. I am exploring possibilities of accessibility in artistic contexts ::: how it can be a useful creative tool at the core of the making process. I put myself through school working as a sign language interpreter. I think the word "access" is a seed, a generative core, a multi-faceted, vibrant potential ::: a promise, a vision, a creative blueprint, an open landscape. I am trying to get better at this aspect of creating space.
	</p><p>
	The tenets of universal design are synergistic with the original dreams of a free and open, accessible web. I choose the accessible, affordable, community-driven tools of the web with purpose. Code is a human-readable text ::: a literature, a score, a script. The dream of the early internet was similar to the vision of radio, cable-access television, video. It promised an accessible, affordable medium for community-driven transmission of culture. It is difficult to remember that vision in today's landscape of profit-driven, commerce-mediated web silos. Our creativity is shaped by opaque, proprietary tools.
	</p><p>
	Old-school codework is becoming a folk art as the mainstream technology world is subsumed by proprietary, closed platforms. Generative, networked codework has a materiality :: a legibility ::: a self-documentation of form and process ::: a choreography, a score, a script ::: a blueprint for levers and gears :::: a language of motion and change.
	</p><p>
	Whether present explicitly in my work or not, the cello is a core impulse for me. The cello's tonal range is very close to the human voice. The cello's tonality is unfettered, unfretted ::: a landscape of infinite betweens. The cello has a non-metered, elegiac feel. My sound work emanates from that texture ::: that heart.
	</p><p>
	We are possibly in the midst of our home planet's sixth mass extinction ::: the shift from seemingless endless populations to the feasibly countable ::: finite ::: to the fragility of two to one to none. With breathtaking speed so many species now follow this trajectory to gone.
	</p><p>
	We can feel Walter Benjamin's angel of history whispering around us ::: the witness. Arduous population surveys ::: counts, maps, mathematical models, risk assessments ::: desperate attempts to hold on to last numbers ::: fragments ::: broken webs. Tattered systems ::: plastic torrents ::: carbon skies. Art speaks to what science cannot retrieve.
	</p><p>
	The lament form is found across geographies across cultures across time. Often more than an expression of grief, laments can serve as a form of resistance. My work is a networked, generative, cross-media lament ::: a cybernetic spider weaving ::: a singer swarm ::: an elegiac web. An electric algorithmic Arachne eternally weaving. Arachne's lament ::: the river, her web. 
	</p>
</article>
<!-- <article id="thanks">
	<header>
	<h1><a href="#top">^</a> thanks</h1>
	</header>
	<p> 
		I have been the recipient of numerous commissions, grants, fellowships and residencies from the Jerome Foundation, the McKnight Foundation, Minnesota State Arts Board, American Composers Foundation, Walker Art Center, Northern Lights.mn, Tweed Museum of Art, Zeitgeist New Music Quartet, Arteles International Artist Residency (Finland), Creative Community Leadership Institute (Bush Foundation / Intermedia Arts), United States Artists / Cheswatyr Foundation, Puffin Foundation, the Arrowhead Regional Arts Council and others.
		I am grateful for their support.
	</p>
</article> -->
<!-- metal against metal lament wind through pipeline lament electric static powerline lament broken chain bicycle rusted lament the lad leapt jumped he climbed and flew the grief of forsaken bicycle the boy the bicycle the metal ladder the sky the parched field rib furrow grief empty silo river scraping rocks the starfish boiled sun stone ink rock held grief harsh rim of heat smoke heavy cloud no rain fire cloud
that wave no hill boatless body so far below the land
grief beak wing cyclone metal shack egret ancient iron pump dry well cry
a season a year a geologic burial
the buzz a din scrape pitch bent friction sunlit dust storm
the cellar the throat the land
that hum the buzz insect wing no insect sand
no bird but asphalt roof
cellophane and wind
no moth but flame a howl

from down the dry dirt
road a limping 3/2 meter -->

</main>
</div>
</div>
<div id="hidetext"><a id="hidetextlink" href="#" title="hide text">-</a></div>
</body>
<script src="/code/velocity.min.js"></script>
<script src="/code/kefir201911.min.js"></script>
<!-- <script src="/code/atlasabsence.js"></script> -->
<script>
let width = window.innerWidth, height = window.innerHeight;
let min = Math.min(width, height), max = Math.max(width, height);
let version = (min < 680 || max < 980) ? "small" : "large";
let v = version === "small" ? 0 : 1;
let z = {};
z.tools = {
	randominteger: (min, max) => {
		return Math.floor( min + Math.random()*(max-min));
	},
	logmsg: function(msg) {
		try { 
			console.log("### ::: " + msg); 
		}
		catch(err) { z.tools.logerror(err) }
	},
	logerror: function(error) {
		try { console.log("rusty error ... " + error); }
		catch(err) {}
	},
	randomhighharmonic: () => {
		let multipliers = [10.0, 12.5, 13.33, 15, 20];
		return multipliers[ z.tools.randominteger( 0, multipliers.length) ];
	},
	randomharmonic: () => {
		let multipliers = [5, 7.5, 10.0, 12.5, 13.33, 15, 20];
		return multipliers[ z.tools.randominteger( 0, multipliers.length) ];
	},
	randomlowharmonic: () => {
		let multipliers = [5, 7.5, 10.0, 12.5, 13.33, 15, 20];
		return multipliers[ z.tools.randominteger( 0, multipliers.length) ]/2;
	},
	randomkey: (object) => {
		let keys = Object.keys(object);
		let key = keys[z.tools.randominteger(0,keys.length)];
		// z.tools.logmsg("key = " + key);
		return key;
	},
	datestr: (date, options) => {
		if(options===undefined) options = {year: "numeric", month: "2-digit", day: "numeric", hour12: true, hour: "2-digit", minute: "2-digit", second: "2-digit"};
		return date.toLocaleTimeString("en-US", options);
		//new Date().toLocaleTimeString("en-US", {year: "numeric", month: "2-digit", day: "numeric", hour12: true, hour: "2-digit", minute: "2-digit", second: "2-digit"});
	},
	togrid: (min=1, max=1, x=1, ndivisions=1) => {
		let dx = Math.floor( (max-min) / ndivisions );
		return Math.floor( ( x-min+dx/2)/dx )*dx + min;
	},
};
//core elements
z.elements = ( () => {
	return {
		body: { el: document.querySelector("body") },
		main: { el: document.querySelector("main") },
		// clock: { el: document.querySelector("#clock") },
		// telegraph: { el: document.querySelector("#telegraph") },
		svg:  { el: document.querySelector("#svg") },
		frames: ["subtextframe", "svgframe", "wordframe", "contentframe"].reduce( (acc, id) => {
			z.tools.logmsg("create frame element ::: " + id);
			acc[id] = { el: document.querySelector("#"+id) };
			return acc;
		}, {}),
	}
})()
	
z.streams = {
	clock: ( () => {
	let dt = 1;
	let date0 = new Date();
	let t0 = Math.floor(date0.getTime()/1000);
	let state0 = { dt: dt, count: 0, date: date0, t: t0, t0: t0 };
	return Kefir.withInterval( dt*1000, emitter => { emitter.emit( { date: new Date() } ) })
			.scan( (state, e) => { 
				state.date = e.date;
				state.t = Math.floor(e.date.getTime()/1000);
				state.count = state.count + 1;
				return state;
			}, state0  )
	})( ),
	dimensions: ( () => {
		let dt = .4;
		const ngrids=[2,2], npasts=[0,0];
		let state0 = { dt: dt, count: 0,
			grid: { nrows: ngrids[v], ncols: ngrids[v], dx: Math.floor(width/ngrids[v]), dy: Math.floor(height/ngrids[v]), sw: 12, pastn: npasts[v] },
			width: width, height: height, 
			max: max, min: min, 
		};
		return Kefir.fromEvents(window, "resize").throttle(dt*1000)
			.scan( (state,e) => {
				state.width = window.innerWidth;
				state.height = window.innerHeight;
				state.max = Math.max(state.width, state.height);
				state.min = Math.min(state.width, state.height);
				state.grid.dx = Math.floor(state.width/state.grid.ncols);
				state.grid.dy = Math.floor(state.height/state.grid.nrows);
				state.grid.sw = Math.floor(Math.max(state.grid.dx*.03, state.grid.dy*.03, 4));
				return state
			}, state0) 
	})( ),
};

z.draw = z => {
	const timings = [ [380,600], [400,580], [480,500], [500,480], [580,400], [600,380], [640,340], [680,300], [700,280], [740,240], [780,200], [800,180], [840,140], [880,100]];
	// const timings = [ [180,800], [200,780], [280,700], [300,680], [380,600], [400,580], [480,500], [500,480], [580,400], [600,380], [640,340], [680,300], [700,280], [740,240], [780,200], [800,180], [840,140], [880,100]];
	// z.streams["clock"].onValue( e => {
	// 	z.elements["clock"].el.innerHTML = z.tools.datestr(new Date(e.t*1000));
	// });

	const playlist = [
		["#fcfbe3", "#191918"], //"warmbw",
		["#9a0000", "#fcfbe3", "#191918"], //"warmbwred",
		["#fcfbe3", "#191918"], //"warmbw",
		["#ffcc00", "#fcfbe3", "#191918"], //"warmbwyellow",
		["#fcfbe3", "#191918"], //"warmbw",
		// ["#006699", "#fcfbe3", "#191918"], //"warmbwblue",
	];
	z.streams["color"] = ( dt => {
		let date0 = new Date();
		let t0 = Math.floor(date0.getTime()/1000);
		let state0 = { 
			dt: dt, count: 0,
			choices: playlist[ Math.floor(t0/dt)%playlist.length ]
		};
		return z.streams["clock"].filter( e => e.t%dt===0 )
			.scan( (state, e) => { 
				state.choices = playlist[ Math.floor(e.t/dt)%playlist.length ];
				state.count = state.count + 1;
				return state;
			}, state0  )
	})( 48 );
	
	z.streams["draw"] = Kefir.combine([z.streams["clock"]], [z.streams["dimensions"], z.streams["color"]], (clock, dimensions, color) => { return {clock:clock, dimensions:dimensions, color:color} })
		.scan( (state, e) => { 
			state.clock = e.clock;
			state.dimensions = e.dimensions;
			state.color = e.color;
			state.count = state.count + 1;
			// z.tools.logmsg("color.choices = " + e.color.choices);
			return state;
	}, {clock:{t:0}, dt:1}  );

	//box
	( dt => {
		const element = document.createElementNS("http://www.w3.org/2000/svg", "rect");
		element.setAttributeNS(null, "id", "box");
		element.setAttributeNS(null, "class", "shape square");
		z.elements["svg"].el.appendChild(element);
			
		z.streams["draw"].filter(e => e.clock.t%dt===0).onValue( e => {
			try {
				let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
				Velocity({	
					elements: element, 
					properties: { fillOpacity: 1.0, strokeOpacity: 0.0, fill: color, width: e.dimensions.width, height: e.dimensions.height },
					options: { duration: 2000,  delay: 0, easing: "easeInOutQuad" },
				});
			} catch(err) { z.tools.logerror("box animation ::: " + err ) }
		})
	})(5);

	//poems
	( dt => {
		const afterclassnames1 = ["after0", "after1", "after2", "after3", "after4", "after5", "after6", "after7", "after8", "after9", "after10", "after11", "after12", "after13"];
		const afterclassnames2 = ["afterblackwhite", "afterwhiteblack"];
		const warmblacktints = ["#191918", "#2f2f2f", "#464646", "#5e5e5d", "#757574", "#8c8c8b", "#a3a3a2", "#babab9", "#d1d1d0", "#e8e8e7", "#ffffff", "#fcfbe3", "#e2e1cc", "#c9c8b5", "#b0af9e", "#979688", "#7e7d71", "#64645a", "#4b4b44", "#32322d", "#191916", "#000000"];
		const elements = ( () => {
			return Array.from(document.querySelectorAll(".poem")).reduce( (acc,el,j)=> {
				z.tools.logmsg("create poem element ::: " + j);
				// el.setAttribute("id", "poem"+j);
				acc[j]={ el:el, id:"poem"+j, stanzas: Array.from(el.querySelectorAll(".stanza")).reduce( (acc,el,j)=> {
					// z.tools.logmsg("el.className ::: " + el.className);
					el.setAttribute("id", "stanza"+j);
					el.className= "stanza " + afterclassnames1[j%afterclassnames1.length] + " " + afterclassnames2[0];

					acc[j]={ el:el, lines:Array.from(el.querySelectorAll("li")).reduce( (acc,el,j)=> {
						// z.tools.logmsg("create line element ::: " + j);
						// el.setAttribute("id", "line"+j);
						acc[j]={ el:el };
						return acc;
						}, []) }; 
					return acc;
				}, []) };
				return acc;
			}, []);
		})();
		z.streams["draw"].filter(e => e.clock.t%dt===0).onValue( e => {
			try {
				let count = e.clock.t/dt;
				let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
				elements.forEach((poem,p) => {
					poem["stanzas"].forEach((stanza,s) => {
						if(count%2===0) {
							stanza.el.className= "stanza " + afterclassnames2[count/2%afterclassnames2.length] + " " + afterclassnames1[z.tools.randominteger(0,afterclassnames1.length)];
						}
						else {
							stanza["lines"].forEach( (line,l) => {
								// line.el.style["color"] = warmblacktints[z.tools.randominteger(0,warmblacktints.length)];
								// line.el.style["color"] = e.clock.t%15<4 ? "#ffffff" : warmblacktints[z.tools.randominteger(0,warmblacktints.length)];
								line.el.style["color"] = e.clock.t%48<4 ? "#fcfbe3" : e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
							})
						}
					})
				});
			} catch(err) { z.tools.logerror("poem animation ::: " + err ) }
		})
	})(7);


	//main
	// ( dt => {
	// 	const element = document.querySelector("main");
	// 	const bgcolors = ["rgba(25, 25, 24, 0.4)", "rgba(25, 25, 24, 0.8)", "rgba(25, 25, 24, 0.9)", "rgba(252, 251, 227, 0.8)", "rgba(252, 251, 227, 0.9)", , "rgba(252, 251, 227, 0.8)"]
			
	// 	// const warmblacktints = ["#191918", "#2f2f2f", "#464646", "#5e5e5d", "#757574", "#8c8c8b", "#a3a3a2", "#babab9", "#d1d1d0", "#e8e8e7", "#ffffff", "#fcfbe3", "#e2e1cc", "#c9c8b5", "#b0af9e", "#979688", "#7e7d71", "#64645a", "#4b4b44", "#32322d", "#191916", "#000000"];
	// 	const warmblacktints = ["#191918", "#fcfbe3", "#000000"];

	// 	z.streams["draw"].filter(e => e.clock.t%dt===0).onValue( e => {
	// 		try {
	// 			let count = e.clock.t/dt;
	// 			let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
	// 			Velocity({	
	// 				elements: element, 
	// 				properties: { backgroundColor:  e.clock.t%48<4 ? "#191918" : color, backgroundColorAlpha: e.clock.t%48<4 ? 0.8 : z.tools.randominteger(6,10)/10},
	// 				options: { duration: 1200,  delay: 0, easing: "easeInOutQuad" },
	// 			});
	// 			if(count%48===0) { 
	// 				if(main.getAttribute("data-state") === "expanded") { 
	// 					main.classList.remove("expand"); main.classList.add("compress");
	// 					main.setAttribute("data-state", "compressed"); 
	// 				} 
	// 				else { 
	// 					main.classList.remove("compress"); main.classList.add("expand");
	// 					main.setAttribute("data-state", "expanded");
	// 				};
	// 			}

	// 		} catch(err) { z.tools.logerror("main animation ::: " + err ) }
	// 	})
	// })(9);


	//words
	( dt => {
		const nwords = [[0,1],[0,1,2,3]][v];
		const words = ["_.._._+ . < +=_.._._+ . < +=_.._._+ . < +=: :  . < > '",
		". . . . . .& | { . . ::: x",
		// "it was like this every morning", ".. - / .-- .- ... / .-.. .. -.- . / - .... .. ... / . ...- . .-. -.-- / -- --- .-. -. .. -. --.", //it was like this every morning
		// "aXQgd2FzIGxpa2UgdGhpcyBldmVyeSBtb3JuaW5n", //it was like this every morning
		"01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100", //hello world
		// "aGVsbG8gd29ybGQ=", //hello world
		"i0i000i0000iiii0i000i0000iii", //i
		"_.._._+ . < +=_.._._+ . < +=_.._._+ . < +=: :  . < > '",". . . . . .& | { . . ::: x",
		// "#thecount ‰ 0 1 2 3 4 5 6 7 8 9 iº #aftercount #aftertime", //
		// "høly h0L¥ hølY H0ly ® Å",
		"Ö x x x ø 0 Ø x X x ø 0 Ø xº3",
		// "forEach Å øn t0uch Ž",
		".. - / .-- .- ... / .-.. .. -.- . / - .... .. ... / . ...- . .-. -.-- / -- --- .-. -. .. -. --."];
		const elements = nwords.reduce( (acc, id, j) => {
			z.tools.logmsg("create word element ::: " + id);
			let el = document.createElement("div");
			el.setAttribute("id", "word_" + id);
			el.setAttribute("class", "absolute monospace_zerodot");
			// el.setAttribute("style", "font-size:"+Math.max(20,100/nwords.length)+"vh, opacity:0");
			el.innerHTML = words[j%words.length];
			z.elements["frames"]["wordframe"].el.appendChild(el);
			el.style[ "fontSize" ] = Math.max(20,100/nwords.length)+"vh";
			el.style[ "opacity" ] = 0.0;
			el.style[ "whiteSpace" ] = "nowrap";
			acc[id] = { el: el };
			return acc;
		}, []);
		const drawings = [
			e => {
				try {
					let dy = Math.floor(e.dimensions.height/elements.length);
					let count = e.clock.t/dt;
					let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
					elements.forEach( (element, j) => {
						element.el.innerText = words[(count+j)%words.length];
						let textwidth = element.el.clientWidth;
						let direction=(j+count)%2===0 ? -1.0 : 1.0;
						let startleft = (j+count)%2===0 ? e.dimensions.width : -2.0*textwidth;
						let endleft = (j+count)%2===1 ? e.dimensions.width : -2.0*textwidth;
						element.el.style[ "left" ] = startleft;
						element.el.style[ "top" ] = (j*dy-dy/3) + "px";
						Velocity({	
							elements: element.el,
							properties: { opacity:0.4 },
							options: { duration: dt*100,  delay: 0 },
						});
						Velocity({	
							elements: element.el,
							properties: { opacity:1.0, left: endleft, color: color },
							options: { duration: z.tools.randominteger(dt*200,dt*400),  delay: z.tools.randominteger(0, dt*220), easing: "linear" },
						});
						Velocity({	
							elements: element.el,
							properties: { opacity:0.0 },
							options: { duration: dt*280,  delay: 0 },
						});
					})
				} catch(err) { z.tools.logerror("word 1 animation ::: " + err ) }
			},
		]
		z.tools.logmsg("#circ elements = " + elements.length);
		z.streams["draw"].filter(e => e.clock.t%dt===0).onValue( e => {
			drawings[Math.floor(e.clock.t/(dt*elements.length))%drawings.length](e);
		})
	})(18);

	//lines
	( dt => {
		const nlines=[[0,1,2,3],[0,1,2,3,4,5,6,7]][v];
		const elements = nlines.reduce( (acc, id) => {
			z.tools.logmsg("create line element ::: " + id);
			let el = document.createElementNS("http://www.w3.org/2000/svg", "line");
			el.setAttributeNS(null, "id", "line_"+ id);
			el.setAttributeNS(null, "class", "shape line");
			z.elements["svg"].el.appendChild(el);
			acc[id] = { el: el };
		return acc;
		}, []);
		const drawings = [
			e => {
				try {
					let dx = e.dimensions.grid.dx, dy = e.dimensions.grid.dy;
					let timing = timings[z.tools.randominteger(0,timings.length)];
					elements.filter((element,j) => j%2===0).forEach( (element, j) => {
						let cy = e.dimensions.height/2;
						let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
						Velocity({	
							elements: elements[2*j].el,
							properties: { strokeOpacity: 1.0, stroke: color, strokeWidth: z.tools.randominteger(12, e.dimensions.max), strokeDasharray: z.tools.randominteger(8, e.dimensions.min), x1: 0, x2: e.dimensions.width, y1: cy, y2: cy },
							options: { duration: z.tools.randominteger(e.dt*timing[0], e.dt*timing[0]*3),  delay: 200 },
						});
						color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];

						Velocity({	
							elements: elements[2*j+1].el,
							properties: { strokeOpacity: 1.0, stroke: color, strokeWidth: z.tools.randominteger(10, e.dimensions.min), strokeDasharray: z.tools.randominteger(4, e.dimensions.min/4), x1: 0, x2: e.dimensions.width, y1: cy, y2: cy },
							options: { duration: z.tools.randominteger(e.dt*timing[0], e.dt*timing[0]*3),  delay: 300 },
						});
					})
				} catch(err) { z.tools.logerror("line animation 1 ::: " + err ) }
			},
			e => {
				try {
					let dx = e.dimensions.grid.dx, dy = e.dimensions.grid.dy;
					let timing = timings[z.tools.randominteger(0,timings.length)];
					elements.filter((element,j) => j%2===0).forEach( (element, j) => {
						let cx = (j%e.dimensions.grid.ncols)*dx + dx/2;
						let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
						Velocity({	
							elements: elements[2*j].el,
							properties: { strokeOpacity: 1.0, stroke: color, strokeWidth: z.tools.randominteger(12, e.dimensions.max), strokeDasharray: z.tools.randominteger(8, e.dimensions.min), y1: 0, y2: e.dimensions.height, x1: cx, x2: cx },
							options: { duration: z.tools.randominteger(e.dt*timing[0], e.dt*timing[0]*3),  delay: 0 },
						});
						color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
						timing = timings[z.tools.randominteger(0,timings.length)];
						Velocity({	
							elements: elements[2*j+1].el,
							properties: { strokeOpacity: 1.0, stroke: color, strokeWidth: z.tools.randominteger(10, e.dimensions.min), strokeDasharray: z.tools.randominteger(4, e.dimensions.min/4), y1: 0, y2: e.dimensions.height, x1: cx, x2: cx },
							options: { duration: z.tools.randominteger(e.dt*timing[0], e.dt*timing[0]*3),  delay: 500 },
						});
					})
				} catch(err) { z.tools.logerror("line animation 2 ::: " + err ) }
			},
			e => {
				try {
					let dx = e.dimensions.grid.dx, dy = e.dimensions.grid.dy;
					let timing = timings[z.tools.randominteger(0,timings.length)];
					elements.filter((element,j) => j%2===0).forEach( (element, j) => {
						// let cx = (j%e.dimensions.grid.ncols)*dx + dx/2;
						let cx = e.dimensions.width/2;
						let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
						Velocity({	
							elements: elements[2*j].el,
							properties: { strokeOpacity: 1.0, stroke: color, strokeWidth: z.tools.randominteger(e.dimensions.max/2, e.dimensions.max), strokeDasharray: z.tools.randominteger(8, e.dimensions.min), y1: 0, y2: e.dimensions.height, x1: cx, x2: cx },
							options: { duration: z.tools.randominteger(e.dt*timing[0], e.dt*timing[0]*3),  delay: 0 },
						});
						color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
						timing = timings[z.tools.randominteger(0,timings.length)];
						Velocity({	
							elements: elements[2*j+1].el,
							properties: { strokeOpacity: 1.0, stroke: color, strokeWidth: z.tools.randominteger(e.dimensions.min/2, e.dimensions.min), strokeDasharray: z.tools.randominteger(4, e.dimensions.min/4), y1: 0, y2: e.dimensions.height, x1: cx, x2: cx },
							options: { duration: z.tools.randominteger(e.dt*timing[0], e.dt*timing[0]*3),  delay: 500 },
						});
					})
				} catch(err) { z.tools.logerror("line animation 2 ::: " + err ) }
			},
			e => {
				try {
					let dx = e.dimensions.grid.dx, dy = e.dimensions.grid.dy;
					let timing = timings[z.tools.randominteger(0,timings.length)];
					elements.filter((element,j) => j%2===0).forEach( (element, j) => {
						// let cx = (j%e.dimensions.grid.ncols)*dx + dx/2;
						let cx = e.dimensions.width/2;
						let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
						Velocity({	
							elements: elements[2*j].el,
							properties: { strokeOpacity: 1.0, stroke: color, strokeWidth: z.tools.randominteger(e.dimensions.max/2, e.dimensions.max), strokeDasharray: z.tools.randominteger(8, e.dimensions.min), y1: 0, y2: e.dimensions.height, x1: cx, x2: cx },
							options: { duration: z.tools.randominteger(e.dt*timing[0], e.dt*timing[0]*3),  delay: 0 },
						});
						color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
						timing = timings[z.tools.randominteger(0,timings.length)];
						Velocity({	
							elements: elements[2*j+1].el,
							properties: { strokeOpacity: 1.0, stroke: color, strokeWidth: z.tools.randominteger(e.dimensions.min/2, e.dimensions.min), strokeDasharray: z.tools.randominteger(4, e.dimensions.min/4), y1: 0, y2: e.dimensions.height, x1: cx, x2: cx },
							options: { duration: z.tools.randominteger(e.dt*timing[0], e.dt*timing[0]*3),  delay: 500 },
						});
					})
				} catch(err) { z.tools.logerror("line animation 2 ::: " + err ) }
			},
			e => {
				try {
					let dx = e.dimensions.grid.dx, dy = e.dimensions.grid.dy;
					let timing = timings[z.tools.randominteger(0,timings.length)];
					elements.filter((element,j) => j%2===0).forEach( (element, j) => {
						let cy = j%2===0 ? 0 : e.dimensions.height/2;
						let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
						Velocity({	
							elements: elements[2*j].el,
							properties: { strokeOpacity: 1.0, stroke: color, strokeWidth: z.tools.randominteger(12, e.dimensions.max), strokeDasharray: z.tools.randominteger(8, e.dimensions.min), y1: cy, y2: cy, x1: 0, x2: e.dimensions.width },
							options: { duration: z.tools.randominteger(e.dt*timing[0], e.dt*timing[0]*3),  delay: 0 },
						});
						color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
						timing = timings[z.tools.randominteger(0,timings.length)];
						Velocity({	
							elements: elements[2*j+1].el,
							properties: { strokeOpacity: 1.0, stroke: color, strokeWidth: z.tools.randominteger(10, e.dimensions.min*2), strokeDasharray: z.tools.randominteger(4, e.dimensions.min/2), y1: cy, y2: cy, x1: 0, x2: e.dimensions.width },
							options: { duration: z.tools.randominteger(e.dt*timing[0], e.dt*timing[0]*3),  delay: 300 },
						});
					})
				} catch(err) { z.tools.logerror("line animation 3 ::: " + err ) }
			}
		];
		z.streams["draw"].filter(e => e.clock.t%dt===0).onValue( e => {
			drawings[Math.floor(e.clock.t/(dt*elements.length))%drawings.length](e);
		})
	})(3);

	//circles
	( dt => {
		const ncircles=[[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7,8,9,10,12,13,14,15]][v];
		const elements = ncircles.reduce( (acc, id) => {
			z.tools.logmsg("create circle element ::: " + id);
			let el = document.createElementNS("http://www.w3.org/2000/svg", "circle");
			el.setAttributeNS(null, "id", "circle_"+ id);
			el.setAttributeNS(null, "class", "shape circle");
			z.elements["svg"].el.appendChild(el);
			acc[id] = { el: el };
			return acc;
		}, []);
		// const elements = z.elements["circles"];
		const drawings = [
			e => {
				try {
					let count = e.clock.t/dt;
					let l = elements.length;
					let minradius = e.dimensions.min/l*z.tools.randominteger(3,14)/10;
					elements.forEach( (element, j) => {
						if(z.tools.randominteger(0,10)<8) {
							let cy = Math.floor(e.dimensions.height/2);
							let cx = Math.floor(e.dimensions.width/2);
							let radius = (l-j)*minradius;
							// z.tools.logmsg("circle 1 cx= "+cx+" cy= " + cy + " radius = " + radius);
							let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
							Velocity({	
								elements: element.el,
								properties: { fillOpacity: (j+count)%3===0 ? 1.0 : 0.0, strokeOpacity: (j+count)%2===0 ? 0.0 : 1.0, stroke: color, strokeWidth: z.tools.randominteger(4,radius/2), strokeDasharray: z.tools.randominteger(4, radius*2), fill: color, cx: cx, cy: cy, r: radius },
								options: { duration: z.tools.randominteger(e.dt*400, e.dt*400*4), delay: j*60 },
							});
						}
						
					})
				} catch(err) { z.tools.logerror("circles 1 animation ::: " + err ) }
			},
			e => {
				try {
					let count = e.clock.t/dt;
					let l = elements.length;
					let minradius = e.dimensions.min/l*z.tools.randominteger(3,20)/10;
					elements.forEach( (element, j) => {
						if(z.tools.randominteger(0,10)<8) {
							let cy = Math.floor(e.dimensions.height/2);
							let cx = Math.floor(e.dimensions.width/2);
							let radius = (l-j)*minradius;
							// z.tools.logmsg("circle 2 cx= "+cx+" cy= " + cy + " radius = " + radius);
							let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
							Velocity({	
								elements: element.el,
								properties: { fillOpacity: (j+count)%5===0 ? 1.0 : 0.0, strokeOpacity: (j+count)%5===0 ? 0.0 : 1.0, stroke: color, strokeWidth: z.tools.randominteger(4,radius/8), strokeDasharray: z.tools.randominteger(4, radius*2), fill: color, cx: cx, cy: cy, r: radius },
								options: { duration: z.tools.randominteger(e.dt*400, e.dt*400*4), delay: j*60 },
							});
						}
						
					})
				} catch(err) { z.tools.logerror("circles 1 animation ::: " + err ) }
			},
			e => {
				try {
					let count = e.clock.t/dt;
					let l = elements.length;
					let minradius = e.dimensions.min/l*z.tools.randominteger(4,20)/10;
					elements.forEach( (element, j) => {
						if(z.tools.randominteger(0,10)<8) {
							let cy = Math.floor(e.dimensions.height/2);
							let cx = Math.floor(e.dimensions.width/2);
							let radius = (l-j)*minradius;
							// z.tools.logmsg("circle 3 cx= "+cx+" cy= " + cy + " radius = " + radius);
							let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
							Velocity({	
								elements: element.el,
								properties: { fillOpacity: (j+count)%2===0 ? 1.0 : 0.0, strokeOpacity: (j+count)%2===0 ? 0.0 : 1.0, stroke: color, strokeWidth: z.tools.randominteger(4,radius/8), strokeDasharray: z.tools.randominteger(4, radius*2), fill: color, cx: cx, cy: cy, r: radius },
								options: { duration: z.tools.randominteger(e.dt*400, e.dt*400*4), delay: j*60 },
							});
						}
						
					})
				} catch(err) { z.tools.logerror("circles 1 animation ::: " + err ) }
			},
			// e => {
			// 	try {
			// 		let dx = e.dimensions.grid.dx, dy = e.dimensions.grid.dy;
			// 		let min = Math.min(dx,dy);
			// 		let count = e.clock.t/dt;
			// 		let cys = [e.dimensions.height/3, 2*e.dimensions.height/3, e.dimensions.height/3, 2*e.dimensions.height/3];
			// 		let cxs = [e.dimensions.width/3, e.dimensions.width/3, 2*e.dimensions.width/3, 2*e.dimensions.width/3];
			// 		elements.forEach( (element, j) => {
			// 			if(z.tools.randominteger(0,10)<6) {
			// 				// let cy = Math.floor(j/(2*e.dimensions.grid.ncols))*dy  + dy/2;
			// 				// let cx = (j%e.dimensions.grid.ncols)*dx + dx/2;
			// 				let cx = cxs[j%cxs.length], cy = cys[j%cys.length]
			// 				let radius = min*z.tools.randominteger(1,6)/10;
			// 				z.tools.logmsg("circle 2 cx= "+cx+" cy= " + cy + " radius = " + radius); 
			// 				let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
			// 				Velocity({	
			// 					elements: element.el,
			// 					properties: { fillOpacity: (j+count)%3===0 ? 1.0 : 0.0, strokeOpacity: (j+count)%2===0 ? 0.0 : 1.0, stroke: color, strokeWidth: z.tools.randominteger(10,radius*2), strokeDasharray: z.tools.randominteger(4, radius*4), fill: color, cx: cx, cy: cy, r: radius },
			// 					options: { duration: z.tools.randominteger(e.dt*400, e.dt*400*4), delay: j*60 },
			// 				});
			// 			}

			// 		})
			// 	} catch(err) { z.tools.logerror("circles 2 animation ::: " + err ) }
			// },
			e => {
				try {
					let dx = e.dimensions.grid.dx, dy = e.dimensions.grid.dy;
					let min = Math.min(dx,dy);
					let count = e.clock.t/dt;
					elements.forEach( (element, j) => {
						if(z.tools.randominteger(0,10)<8) {
							let cy = e.dimensions.height/2;
							let cx = j%3===0 ? 0 : (j%2===0 ? e.dimensions.width/2 : e.dimensions.width);
							let radius = min*z.tools.randominteger(1,20)/10;
							// z.tools.logmsg("circle 3 cx= "+cx+" cy= " + cy + " radius = " + radius); 
							// if(Math.floor(count)%3!==0 && j%e.dimensions.grid.ncols===0) { color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];}
							// if(Math.floor(count)%4!==0 && j%e.dimensions.grid.nrows===0) { color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];}
							let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
							Velocity({	
								elements: element.el,
								properties: { fillOpacity: (j+count)%3===0 ? 1.0 : 0.0, strokeOpacity: (j+count)%2===0 ? 0.0 : 1.0, stroke: color, strokeWidth: z.tools.randominteger(10,radius*2), strokeDasharray: z.tools.randominteger(4, radius*4), fill: color, cx: cx, cy: cy, r: radius },
								options: { duration: z.tools.randominteger(e.dt*400, e.dt*400*4), delay: j*60 },
							});
						}
					})
				} catch(err) { z.tools.logerror("circles 3 animation ::: " + err ) }
			},
			e => {
				try {
					let dx = e.dimensions.grid.dx, dy = e.dimensions.grid.dy;
					let min = Math.min(dx,dy);
					let count = e.clock.t/dt;
					
					elements.forEach( (element, j) => {
						if(z.tools.randominteger(0,10)<8) {
							let cy = e.dimensions.height/2;
							let cx = j%2===0 ? e.dimensions.width/2 -dx : e.dimensions.width/2 + dx;
							let radius = min*z.tools.randominteger(1,20)/10;
							// z.tools.logmsg("circle 4 cx= "+cx+" cy= " + cy + " radius = " + radius); 
							let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
							Velocity({	
								elements: element.el,
								properties: { fillOpacity: (j+count)%5===0 ? 1.0 : 0.0, strokeOpacity: (j+count)%2===0 ? 0.0 : 1.0, stroke: color, strokeWidth: z.tools.randominteger(10,radius*2), strokeDasharray: z.tools.randominteger(4, radius*4), fill: color, cx: cx, cy: cy, r: radius },
								options: { duration: z.tools.randominteger(e.dt*400, e.dt*400*3), delay: j*60 },
							});
						}

					})
				} catch(err) { z.tools.logerror("circles 4 animation ::: " + err ) }
			},
			e => {
				try {
					let dx = e.dimensions.grid.dx, dy = e.dimensions.grid.dy;
					let min = Math.min(dx,dy);
					let count = e.clock.t/dt;
					
					elements.forEach( (element, j) => {
						if(z.tools.randominteger(0,10)<6) {
							let cy = e.dimensions.height/2;
							let cx = j%2===0 ? e.dimensions.width/2 -dx : e.dimensions.width/2 + dx;
							let radius = min*z.tools.randominteger(1,30)/10;
							// z.tools.logmsg("circle 4 cx= "+cx+" cy= " + cy + " radius = " + radius); 
							let color = e.color.choices[z.tools.randominteger(0, e.color.choices.length)];
							Velocity({	
								elements: element.el,
								properties: { fillOpacity: (j+count)%5===0 ? 1.0 : 0.0, strokeOpacity: (j+count)%5===0 ? 0.0 : 1.0, stroke: color, strokeWidth: z.tools.randominteger(10,radius*2), strokeDasharray: z.tools.randominteger(4, radius*4), fill: color, cx: cx, cy: cy, r: radius },
								options: { duration: z.tools.randominteger(e.dt*400, e.dt*400*3), delay: j*60 },
							});
						}

					})
				} catch(err) { z.tools.logerror("circles 4 animation ::: " + err ) }
			}
		]
		z.tools.logmsg("#circ elements = " + elements.length);
		z.streams["draw"].filter(e => e.clock.t%dt===0).onValue( e => {
			drawings[Math.floor(e.clock.t/(dt*elements.length))%drawings.length](e);
		})
	})(2);

};
z.radio = ( () => { 
	const soundcorepath = "/data/sound/";
	const instruments = {
		bagpipe1a: {clip: "bagpipe1a", minvolume: 0.3, maxvolume: 0.9, playbackRate: () => { return z.tools.randomlowharmonic()/10 } },
		bagpipe1ahigh: {clip: "bagpipe1a", minvolume: 0.3, maxvolume: 0.9, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		bagpipe1e: {clip: "bagpipe1e", minvolume: 0.3, maxvolume: 0.9, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		bagpipe1f: {clip: "bagpipe1f", minvolume: 0.3, maxvolume: 0.9, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		bagpipe1g: {clip: "bagpipe1g", minvolume: 0.3, maxvolume: 0.9, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		bagpipe1h: {clip: "bagpipe1h", minvolume: 0.3, maxvolume: 0.9, playbackRate: () => { return z.tools.randomlowharmonic()/10 } },
		bagpipe1: {clip: "bagpipe1", minvolume: 0.3, maxvolume: 0.9, playbackRate: () => { return z.tools.randomlowharmonic()/4 } },
		bagpipe1high: {clip: "bagpipe1", minvolume: 0.3, maxvolume: 0.9, playbackRate: () => { return z.tools.randomharmonic()/4 } },
		birdcry: {clip: "birdcry", minvolume: 0.4, maxvolume: 0.9} ,
		birdcryhigh: {clip: "birdcry", minvolume: 0.4, maxvolume: 0.9, playbackRate: () => { return z.tools.randomhighharmonic()/10} },
		birdcrylow: {clip: "birdcry", minvolume: 0.4, maxvolume: 0.9, playbackRate: () => { return z.tools.randomlowharmonic()/10} },
		mctbreathingharmonic: {clip: "mctbreathing0", minvolume: 0.4, maxvolume: 0.9, playbackRate: () => { return z.tools.randomharmonic()/10} },
		monksfromouterspacecistern_a: {clip: "monksfromouterspacecistern_a", minvolume: 0.4, maxvolume: 0.8 },
		monksfromouterspacecistern_f: {clip: "monksfromouterspacecistern_f", minvolume: 0.4, maxvolume: 0.8, playbackRate: () => { return z.tools.randomhighharmonic()/10 } },
		traffickcorebirds1_a: {clip: "traffickcorebirds1_a", minvolume: 0.4, maxvolume: 0.8, playbackRate: () => { return z.tools.randomhighharmonic()/10 } },
		coffepot1eminor: {clip: "coffepot1eminor", minvolume: 0.4, maxvolume: 0.8, playbackRate: () => { return z.tools.randomhighharmonic()/10 } },



		thunk: {clip: "thunk", minvolume: 0.3, maxvolume: 0.8, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		thunkhighharmonic: {clip: "thunk", minvolume: 0.3, maxvolume: 0.8, playbackRate: () => { return z.tools.randomhighharmonic()/10 } },
		birds5harmonic: {clip: "birds5",minvolume: 0.2, maxvolume: 0.5, playbackRate: () => { return z.tools.randomhighharmonic()/10 } },
		knocking1: {clip: "knocking1", minvolume: 0.4, maxvolume: 0.9, playbackRate: () => { return z.tools.randominteger(4,48)/10 } },
		cmpb20200708_5harmonic: {clip: "cmpb20200708_5", minvolume: 0.4, maxvolume: 0.9, playbackRate: () => { return z.tools.randomhighharmonic()/10 } },//* voice
		// cello_pitch1: {clip: "cello_pitch1", minvolume: 0.3, maxvolume: 0.8, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		// cello_pitch1harmonic: {clip: "cello_pitch1", minvolume: 0.3, maxvolume: 0.8, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		bird1harmonic: {clip: "bird1", minvolume: 0.8, maxvolume: 1.0, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		birdcanyon: {clip: "birdcanyon", minvolume: 0.8, maxvolume: 1.0, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		// bagpipegeese: {clip: "bagpipegeese", minvolume: 0.8, maxvolume: 1.0, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		celloknockcanyon: {clip: "celloknockcanyon", minvolume: 0.8, maxvolume: 1.0, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		voxmct0: {clip: "voxmct0", minvolume: 0.8, maxvolume: 1.0, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		// stapler: {clip: "stapler", minvolume: 0.8, maxvolume: 1.0, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		train1: {clip: "train1", minvolume: 0.4, maxvolume: 0.8, playbackRate: () => { return z.tools.randominteger(6,18)/10 } },
		rubbedpianoharp0: {clip: "rubbedpianoharp0", minvolume: 0.4, maxvolume: 0.8, playbackRate: () => { return z.tools.randominteger(6,18)/10 } },
		sheila: {clip: "sheila", minvolume: 0.4, maxvolume: 0.8, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		

		// weatherradio1: {clip: "weatherradio1", minvolume: 0.6, maxvolume: 1.0,  playbackRate: () => { return z.tools.randominteger(6,12)/10 } },
		// longbell: {clip: "longbell", minvolume: 0.4, maxvolume: 0.8, playbackRate: () => { return z.tools.randominteger(9,18)/10 } },
		// cellothunktelephone: {clip: "cellothunktelephone", minvolume: 0.8, maxvolume: 1.0, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		// cellothunkradio: {clip: "cellothunkradio", minvolume: 0.8, maxvolume: 1.0, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		// t0: {clip: "t0", minvolume: 0.8, maxvolume: 1.0, playbackRate: () => { return z.tools.randomharmonic()/10 } },
		// tornadosirenharmonic: {clip: "tornadosiren", minvolume: 0.1, maxvolume: 0.6, playbackRate: () => { return z.tools.randomlowharmonic()/10 } },									
	};
	let clips = {};
	Object.entries(instruments).forEach( instrument => {
		clips[instrument[1].clip] = { url: soundcorepath + instrument[1].clip + ".mp3", loaded:false, duration:0, buffer:{} };
	});
	let radio = {
		player: {}, loading: [], loaded: false,
		soundplaying:false,
		instruments: instruments, clips: clips,
		clipduration: { min:0, max:0 },
		nbuffersplaying: 0, maxbuffersplaying: [14,18][v],
		intervals: {
			lowi: function(basetone){ return Math.floor(basetone/4) },
			i: function(basetone){ return Math.floor(basetone/2) },
			I: function(basetone){ return Math.floor(basetone/1) },
			II: function(basetone){ return Math.floor(basetone*9/8) },
			III: function(basetone){ return Math.floor(basetone*5/4) },
			iii: function(basetone){ return Math.floor(basetone*6/5) },
			IV: function(basetone){ return Math.floor(basetone*4/3) },
			V: function(basetone){ return Math.floor(basetone*3/2) },
			VI: function(basetone){ return Math.floor(basetone*5/3) },
			VII: function(basetone){ return Math.floor(basetone*15/8) },
			vii: function(basetone){ return Math.floor(basetone*9/5) },
			VIII: function(basetone){ return Math.floor(basetone*2) },
		},
		loadclips: z => {
			Object.keys(z.radio.clips).forEach( key => {
				let clip = z.radio.clips[key];
				if(!z.radio.loading.includes(clip.url)) {
					z.radio.loading.push(clip.url);
					let request = new XMLHttpRequest();
					//for localhost testing
					request.open("GET", window.location.protocol + "//" + window.location.hostname + ":" + window.location.port + "/" + clip.url, true);
					// z.tools.logmsg("url = " + window.location.protocol + "//" + window.location.hostname + ":" + window.location.port + "/web/" + clip.url);
					// for deploy
					// request.open("GET", window.location.protocol + "//" + window.location.hostname + "/" + clip.url, true);
					// z.tools.logmsg("url = " + window.location.protocol + "//" + window.location.hostname + "/"  + clip.url);
					request.responseType = "arraybuffer";
					request.onload = () =>  {
						z.tools.logmsg("loaded" + clip.url);
						z.radio.player.context.decodeAudioData(request.response, buffer => {
							clip.loaded = true;
							clip.buffer = buffer;
							clip.duration = clip.buffer.duration;
							if( clip.duration > z.radio.clipduration.max) {z.radio.clipduration.max = clip.duration}
							else if( clip.duration < z.radio.clipduration.min) {z.radio.clipduration.min  = clip.duration}
							z.tools.logmsg("decoded" + clip.url);
						}, e => {
							z.tools.logerror("audio error! clip = " + clip.url + ", err = " + e);
						});
						
					};
					request.send();
				}
			});
			z.radio.loaded = true;
		},
		start: z => {
			/* set up player*/
			window.AudioContext = window.AudioContext || window.webkitAudioContext;
			z.radio.player.context = new AudioContext();
			/* experimental parameters */
			let parameters = [
				{ gain: 0.4, threshold: -24, knee: 30, ratio: 12, attack: 0.003, release: 0.25 }, //default
				{ gain: 0.3, threshold: -18, knee: 30, ratio: 18, attack: 0.0003, release: 0.28 },
				{ gain: 0.5, threshold: -8, knee: 30, ratio: 18, attack: 0.003, release: 0.28 },
				{ gain: 0.8, threshold: -8, knee: 30, ratio: 18, attack: 0.003, release: 0.28 },
				];
			let n = 0;

			//with compressor
			z.radio.player.compressor = z.radio.player.context.createDynamicsCompressor();
			z.radio.player.compressor.threshold.value = parameters[n].threshold;
			z.radio.player.compressor.knee.value = parameters[n].knee;
			z.radio.player.compressor.ratio.value = parameters[n].ratio;
			
			z.radio.player.compressor.attack.value = parameters[n].attack;
			z.radio.player.compressor.release.value = parameters[n].release;
			z.radio.player.gain = z.radio.player.context.createGain();
			z.radio.player.gain.value = parameters[n].gain;
			z.radio.player.compressor.connect(z.radio.player.gain);
			z.radio.player.gain.connect(z.radio.player.context.destination);
			// //with no compressor
			// z.radio.player.gain = z.radio.player.context.createGain();
			// z.radio.player.gain.value = parameters[n].gain;
			// z.radio.player.gain.connect(z.radio.player.context.destination);
		},
		playtone: ({ volume=0.8, delay=0, fadetime=0.1, duration=1.0, frequency=380 } = {}) => { 
			let vco = z.radio.player.context.createOscillator();
			vco.frequency.value = frequency;
			vco.type = "sine";
			let vca = z.radio.player.context.createGain();
			
			vco.connect(vca);
			vca.connect(z.radio.player.gain);
			let now = z.radio.player.context.currentTime;
			//fade in
			vca.gain.exponentialRampToValueAtTime(0.001, now + delay);
			vca.gain.exponentialRampToValueAtTime(volume, now + fadetime + delay);
			//fade out
			vca.gain.exponentialRampToValueAtTime(volume, now + duration + delay - fadetime);
			vca.gain.exponentialRampToValueAtTime(0.001, now + duration + delay);
			vco.start(now + delay);
			vco.stop(now + delay + duration + fadetime);
			vco.onended = function() {
			  	vco.disconnect(); vca.disconnect();
			}
		},
		playbuffer: ( { volume=0.8, delay=0, fadetime=1, duration=2, instrument=z.radio.instruments["bagpipe1f"] } = {} ) =>  {
			try {
				// let instrument = z.radio.instruments[zinstrument];
				let clip = z.radio.clips[instrument.clip];
				// z.tools.logmsg("***buffer requested = " + instrument.clip + " z.radio.nbuffersplaying = " + z.radio.nbuffersplaying);
				if(clip.loaded && (z.radio.nbuffersplaying<z.radio.maxbuffersplaying-1 || z.radio.nbuffersplaying>z.radio.maxbuffersplaying+2)) {
					let rate = instrument.playbackRate ? instrument.playbackRate() : 1.0;
					try {
						z.tools.logmsg("clip = " + clip.url + " fadetime = " + fadetime  + " rate = " + rate + " ::: volume = " + volume + " ::: duration = " + clip.duration*rate + " || " + duration*rate);
						let vca = z.radio.player.context.createGain(); 
						let source = z.radio.player.context.createBufferSource();
						source.buffer = clip.buffer;
						source["playbackRate"].value = rate;
						source.connect(vca);
						vca.connect(z.radio.player.gain);
						source.loop = false;
						source.onended = e =>  { 
							z.radio.nbuffersplaying=z.radio.nbuffersplaying-1;
						};
						++z.radio.nbuffersplaying;
						let now = z.radio.player.context.currentTime;
						let dur = clip.duration < duration ? clip.duration/rate : rate*duration/rate;
						let dt = Math.min(fadetime, dur*.25);
						let offset = z.tools.randominteger(0, (dur-4*dt)*10)/10;
						// source.start(now, offset, dt*4); //parameters (when,offset,duration)
						vca.gain.setValueAtTime(0.001, now);
						vca.gain.exponentialRampToValueAtTime(volume, now + dt);
						vca.gain.setValueAtTime(volume, dur - 2*dt);
						vca.gain.exponentialRampToValueAtTime(0.001, now + dur-dt*0.5 );
						source.start(now, offset, dur); //parameters (when,offset,duration)
						// z.tools.logmsg("playing = " + clip.url);
					} catch(e) { z.tools.logerror("error applying params to audio buffer e::: " + e) }
				}
				else {	
					z.tools.logmsg("NOT playing = " + clip.url);
				}
			}
			catch(err) { z.tools.logerror("line playbuffer" + err) }
		},
		play: z => {
			const defaultduration = (dt,n,graintdt,clip) => dt/(graindt*2);
			const defaultfadetime = (dt,n,graintdt,clip) => dt/(graindt*20);
			const defaultpart = (dt=4000, n=4, graindt=400, chance=0.8, duration=defaultduration, fadetime=defaultfadetime, instruments=["celloknockcanyon"]) => { return {dt:dt, chance:chance, graindt: graindt, n: 5, duration: duration(dt,n,graintdt), fadetime: fadetime(dt,n,graintdt), instruments: ["celloknockcanyon"] } };
			const score = [
				// ((dt=4000, n=4, graindt=400, chance=0.8) => { return {dt:dt, chance:chance, graindt: graindt, n: 5, duration: dt/(graindt*2), fadetime: dt/(graindt*20), instruments: ["birdcanyon", "birds5harmonic", "voxmct0", "mctbreathingharmonic", "cmpb20200708_5harmonic"] } })(14000,5,500),
				((dt=4000, n=4, graindt=400, chance=0.8) => { return {dt:dt, chance:chance, graindt: graindt, n: 5, duration: dt/(graindt*2), fadetime: dt/(graindt*20), instruments: ["voxmct0"] } })(14000,5,500),
				// ((dt=4000, n=4, graindt=400, chance=0.8) => { return {dt:dt, chance:chance, graindt: graindt, n: 5, duration: dt/(graindt*2), fadetime: dt/(graindt*20), instruments: ["train1", "mctbreathingharmonic", "birdcrylow"] } })(4000,6,500),
				// ((dt=4000, n=4, graindt=400, chance=0.8) => { return {dt:dt, chance:chance, graindt: graindt, n: 5, duration: dt/(graindt*2), fadetime: dt/(graindt*20), instruments: ["celloknockcanyon", "cmpb20200708_5harmonic", "thunkhighharmonic"] } })(5000,3,500,0.6),
				((dt=4000, n=4, graindt=400, chance=0.8) => { return {dt:dt, chance:chance, graindt: graindt, n: 5, duration: dt/(graindt*2), fadetime: dt/(graindt*20), instruments: ["knocking1", "birdcrylow"] } })(17000,6,400,0.8),
				// ((dt=4000, n=4, graindt=400, chance=0.8) => { return {dt:dt, chance:chance, graindt: graindt, n: 5, duration: dt/(graindt*2), fadetime: dt/(graindt*20), instruments: ["celloknockcanyon", "mctbreathingharmonic"] } })(5000,4,400,0.8),
				((dt=4000, n=4, graindt=400, chance=0.8) => { return {dt:dt, chance:chance, graindt: graindt, n: 5, duration: dt/(graindt*2), fadetime: dt/(graindt*20), instruments: ["bagpipe1e","bagpipe1f","bagpipe1g","bagpipe1h"] } })(3000,4,400,0.8),
				((dt=4000, n=4, graindt=400, chance=0.8) => { return {dt:dt, chance:chance, graindt: graindt, n: 5, duration: dt/(graindt*2), fadetime: dt/(graindt*20), instruments: ["cmpb20200708_5harmonic", ] } })(9000,6,400,0.8),
				((dt=17000, n=1, graindt=12000, chance=0.8) => { return {dt:dt, chance:chance, graindt: graindt, n: n, duration: graindt, fadetime: 2, instruments: ["rubbedpianoharp0"] } })(),
				((dt=13000, n=1, graindt=11000, chance=0.8) => { return {dt:dt, chance:chance, graindt: graindt, n: n, duration: graindt, fadetime: 2, instruments: ["traffickcorebirds1_a"] } })(),
				((dt=19000, n=2, graindt=11000, chance=0.8) => { return {dt:dt, chance:chance, graindt: graindt, n: n, duration: graindt, fadetime: 2, instruments: ["sheila"] } })(),
				((dt=18000, n=2, graindt=8000, chance=0.8) => { return {dt:dt, chance:chance, graindt: graindt, n: n, duration: graindt, fadetime: 2, instruments: ["monksfromouterspacecistern_f"] } })(),
				((dt=11000, n=1, graindt=10000, chance=0.8) => { return {dt:dt, chance:chance, graindt: graindt, n: n, duration: graindt, fadetime: 2, instruments: ["train1"] } })(),

			];
			score.forEach( (part,j) => {
				z.streams["clock"].filter( e => e.t%Math.floor(part.dt/1000)===0 && z.tools.randominteger(0,10)<part.chance*10 && z.radio.soundplaying)
					.onValue( e=> {
						let clip = part.instruments[z.tools.randominteger(0,part.instruments.length)];
						Kefir.sequentially(part.graindt, [...Array(part.n).keys()]).onValue( x => { 
							z.radio.playbuffer({duration:part.duration, fadetime:part.fadetime, instrument:z.radio.instruments[clip], volume: z.tools.randominteger(z.radio.instruments[clip].minvolume*10, z.radio.instruments[clip].maxvolume*10)/10});
						});
					})
			});


		}
	};
	
	let soundlink = document.querySelector("#soundlink");
	let telegraph = document.querySelector("#telegraph");

	Kefir.fromEvents(soundlink, "click").onValue( e => {
		z.tools.logmsg("play sound !");
		if(!radio.soundplaying) { 
			try {
				radio.player.context.resume().then(() => {
					z.tools.logmsg("playback resumed");
					// telegraph.innerHTML =  "(sound on)";
					radio.soundplaying = true;
					// soundlink.classList.add("active");
					soundlink.innerText = "turn off sound";
				});
			} catch(e) { z.tools.logerror("dashboard ::: resumeaudio " + e) } 
		}
		else { 
			try {
				radio.player.context.suspend().then(() => {
					// telegraph.innerHTML =  "(sound off)";
					radio.soundplaying = false;
					// soundlink.classList.remove("active");
					soundlink.innerText = "turn on sound";
				});
			} catch(e) { z.tools.logerror("dashboard ::: suspendaudio " + e) }
		}
	});

	return radio;
})();
//controls
( () => { 
	const hidetextlink = document.querySelector("#hidetextlink");
	let texthidden = false;
	Kefir.fromEvents(hidetextlink, "click").onValue( e => {
		if(texthidden) {
			z.elements["main"].el.style["opacity"] = 1.0;
			hidetextlink.innerText = "-";
			hidetextlink.title = "hide text";
			texthidden = false;
		}
		else {
			z.elements["main"].el.style["opacity"] = 0.0;
			hidetextlink.innerText = "+";
			hidetextlink.title = "show text";
			texthidden = true;
		}
	});
})();
z.radio.start(z);
z.radio.loadclips(z);
// z.radio.playtone();
window.addEventListener('load', e => {
  z.radio.play(z);
  z.draw(z);
  window.scroll(0,0);
  // window.setTimeout(() => { document.querySelector("#contentframe").style.opacity = 1.0 }, 1800);
  // window.setTimeout(() => { document.querySelector("#controls").style.backgroundColor = "rgba(0,0,0,0.0)" }, 6800);
});
window.addEventListener('beforeunload', e => {
	window.scroll(0,0);
});
</script>
</html>